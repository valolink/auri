===== START: src/App.vue =====
<script lang="ts">
import { ref } from 'vue'

export default {
  setup() {
    return {}
  },

  mounted() {},
}
</script>

===== END: src/App.vue =====

===== START: src/components/SolarTest.vue =====
<template>
  <div style="padding: 1rem; max-width: 600px; margin: auto">
    <n-input-group>
      <n-input v-model:value="address" type="text" placeholder="Syötä osoite" />
      <n-button type="primary" @click="runTest">Hae</n-button>
    </n-input-group>
    <div
      ref="mapRef"
      style="width: 100%; height: 400px; margin-top: 1rem; border: 1px solid #ccc"
    ></div>
    <p>Geocode:</p>
    <json-viewer
      v-if="geoResult"
      :value="JSON.parse(geoResult)"
      :expand-depth="2"
      copyable
      boxed
      sort
    />

    <p>Building:</p>
    <json-viewer
      v-if="buildingResult"
      :value="JSON.parse(buildingResult)"
      :expand-depth="2"
      copyable
      boxed
      sort
    />

    <p>Data Layers:</p>
    <json-viewer
      v-if="layerResult"
      :value="JSON.parse(layerResult)"
      :expand-depth="2"
      copyable
      boxed
      sort
    />
    <p v-if="error" style="color: red; margin-top: 1rem">{{ error }}</p>
  </div>
</template>

<script setup lang="ts">
import { ref } from 'vue'
import { Loader } from '@googlemaps/js-api-loader'
import { geocodeAddress } from '@/services/geocodingApi'
import { findClosestBuilding } from '@/services/solarApi'
import { getDataLayerUrls } from '@/services/dataLayers'

import JsonViewer from 'vue-json-viewer'
import 'vue-json-viewer/style.css'

import { NInput, NButton, NInputGroup } from 'naive-ui'

const mapRef = ref<HTMLElement | null>(null)
let map: google.maps.Map | null = null
let marker: google.maps.Marker | null = null

const address = ref('Rajatorpantie 8')
const result = ref<string | null>(null)
const error = ref<string | null>(null)
const geoResult = ref<string | null>(null)
const buildingResult = ref<string | null>(null)
const layerResult = ref<string | null>(null)

const apiKey = 'AIzaSyBf1PZHkSB3LPI4sdepIKnr9ItR_Gc_KT4'

const polygon: google.maps.Polygon | null = null

const CanvasOverlay: typeof google.maps.OverlayView | null = null

const initializeMap = async (lat: number, lng: number) => {
  const loader = new Loader({
    apiKey,
    version: 'weekly',
    libraries: ['places'], // optional if you want places search later
  })

  await loader.load()

  if (!mapRef.value) return

  map = new google.maps.Map(mapRef.value, {
    center: { lat, lng },
    zoom: 18,
    mapTypeId: 'satellite',
    tilt: 0, // ✅ Keep map flat (0° tilt)
    heading: 0, // ✅ Ensure north is up
    gestureHandling: 'greedy', // optional: allow full pan/zoom
    rotateControl: false, // optional: disable rotation UI
    mapId: '', // optional: custom map style ID if needed
  })
  marker = new google.maps.Marker({
    position: { lat, lng },
    map,
    title: 'Selected Location',
  })

  const building = await findClosestBuilding({ lat: () => lat, lng: () => lng }, apiKey)
  buildingResult.value = JSON.stringify(building, null, 2)
}

const fetchGeocodeBoundsFromPlaceId = async (placeId: string, apiKey: string) => {
  const url = `https://maps.googleapis.com/maps/api/geocode/json?place_id=${placeId}&key=${apiKey}`
  const response = await fetch(url)
  const data = await response.json()

  if (
    data.status === 'OK' &&
    data.results.length &&
    data.results[0].geometry &&
    (data.results[0].geometry.bounds || data.results[0].geometry.viewport)
  ) {
    const geom = data.results[0].geometry
    return geom.bounds || geom.viewport
  } else {
    throw new Error('No bounds or viewport available for Place ID')
  }
}

const runTest = async () => {
  if (marker) marker.setMap(null)
  result.value = error.value = null
  geoResult.value = buildingResult.value = layerResult.value = null

  const geo = await geocodeAddress(address.value, apiKey)
  await initializeMap(geo.lat, geo.lng)

  const building = await findClosestBuilding({ lat: () => geo.lat, lng: () => geo.lng }, apiKey)
  const placeId = building.name.split('/').pop() || ''
  buildingResult.value = JSON.stringify(building, null, 2)

  geoResult.value = JSON.stringify(geo, null, 2)

  const data = await getDataLayerUrls({ latitude: geo.lat, longitude: geo.lng }, 100, apiKey)
  layerResult.value = JSON.stringify(data, null, 2)

  result.value = layerResult.value

  const rgbUrl = data.rgbUrl
  if (!rgbUrl) throw new Error('No RGB URL available')

  const fetchUrl = new URL(rgbUrl)
  const id = fetchUrl.searchParams.get('id')
  if (!id) throw new Error('No image ID in URL')

  const response = await fetch(`https://solar.googleapis.com/v1/geoTiff:get?id=${id}&key=${apiKey}`)
  const blob = await response.blob()

  const { image, bounds: overlayBounds } = await getGeoTiffBounds(blob)
  const rasters = await image.readRasters({ interleave: true })
  const width = image.getWidth()
  const height = image.getHeight()

  const canvas = document.createElement('canvas')
  canvas.width = width
  canvas.height = height
  const ctx = canvas.getContext('2d')!
  const imageData = ctx.createImageData(width, height)

  for (let i = 0; i < rasters.length; i += 4) {
    imageData.data[i + 0] = rasters[i + 0] // R
    imageData.data[i + 1] = rasters[i + 1] // G
    imageData.data[i + 2] = rasters[i + 2] // B
    imageData.data[i + 3] = 255 // full alpha
  }

  ctx.putImageData(imageData, 0, 0)

  const overlay = new CanvasOverlay(canvas, overlayBounds)
  overlay.setMap(map!)
}

const getGeoTiffBounds = async (blob: Blob) => {
  const { fromArrayBuffer } = await import('geotiff')
  const buffer = await blob.arrayBuffer()
  const tiff = await fromArrayBuffer(buffer)
  const image = await tiff.getImage()
  const [minLng, minLat, maxLng, maxLat] = image.getBoundingBox()
  return {
    image,
    bounds: new google.maps.LatLngBounds(
      { lat: minLat, lng: minLng },
      { lat: maxLat, lng: maxLng },
    ),
  }
}
</script>

===== END: src/components/SolarTest.vue =====

===== START: src/assets/base.css =====
/* color palette from <https://github.com/vuejs/theme> */
:root {
  --vt-c-white: #ffffff;
  --vt-c-white-soft: #f8f8f8;
  --vt-c-white-mute: #f2f2f2;

  --vt-c-black: #181818;
  --vt-c-black-soft: #222222;
  --vt-c-black-mute: #282828;

  --vt-c-indigo: #2c3e50;

  --vt-c-divider-light-1: rgba(60, 60, 60, 0.29);
  --vt-c-divider-light-2: rgba(60, 60, 60, 0.12);
  --vt-c-divider-dark-1: rgba(84, 84, 84, 0.65);
  --vt-c-divider-dark-2: rgba(84, 84, 84, 0.48);

  --vt-c-text-light-1: var(--vt-c-indigo);
  --vt-c-text-light-2: rgba(60, 60, 60, 0.66);
  --vt-c-text-dark-1: var(--vt-c-white);
  --vt-c-text-dark-2: rgba(235, 235, 235, 0.64);
}

/* semantic color variables for this project */
:root {
  --color-background: var(--vt-c-white);
  --color-background-soft: var(--vt-c-white-soft);
  --color-background-mute: var(--vt-c-white-mute);

  --color-border: var(--vt-c-divider-light-2);
  --color-border-hover: var(--vt-c-divider-light-1);

  --color-heading: var(--vt-c-text-light-1);
  --color-text: var(--vt-c-text-light-1);

  --section-gap: 160px;
}

@media (prefers-color-scheme: dark) {
  :root {
    --color-background: var(--vt-c-black);
    --color-background-soft: var(--vt-c-black-soft);
    --color-background-mute: var(--vt-c-black-mute);

    --color-border: var(--vt-c-divider-dark-2);
    --color-border-hover: var(--vt-c-divider-dark-1);

    --color-heading: var(--vt-c-text-dark-1);
    --color-text: var(--vt-c-text-dark-2);
  }
}

*,
*::before,
*::after {
  box-sizing: border-box;
  margin: 0;
  font-weight: normal;
}

body {
  min-height: 100vh;
  color: var(--color-text);
  background: var(--color-background);
  transition:
    color 0.5s,
    background-color 0.5s;
  line-height: 1.6;
  font-family:
    Inter,
    -apple-system,
    BlinkMacSystemFont,
    'Segoe UI',
    Roboto,
    Oxygen,
    Ubuntu,
    Cantarell,
    'Fira Sans',
    'Droid Sans',
    'Helvetica Neue',
    sans-serif;
  font-size: 15px;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

===== END: src/assets/base.css =====

===== START: src/assets/main.css =====
/* @import './base.css'; */

===== END: src/assets/main.css =====

===== START: src/main.ts =====
// main.ts
import './assets/main.css'
import { createApp } from 'vue'
import App from './App.vue'
import { useAppState } from './useAppState'
import SolarTest from './components/SolarTest.vue'

const app = createApp({
  setup() {
    const state = useAppState()
    return state
  },
  components: {
    'solar-test': SolarTest,
  },
})

app.mount('#content')

===== END: src/main.ts =====

===== START: src/useAppState.ts =====
import { ref } from 'vue'

const message = ref('hello')

export function useAppState() {
  return {
    message,
  }
}

===== END: src/useAppState.ts =====

===== START: src/services/imageFetcher.ts =====
export async function fetchGeoTiffImage(imageUrl: string, apiKey: string): Promise<string> {
  const url = new URL(imageUrl)
  const imageId = url.searchParams.get('id') || imageUrl.split('id=')[1]

  if (!imageId) {
    throw new Error('Unable to extract image ID from URL')
  }

  const fetchUrl = `https://solar.googleapis.com/v1/geoTiff:get?id=${imageId}&key=${apiKey}`

  const response = await fetch(fetchUrl)
  if (!response.ok) {
    const text = await response.text()
    throw new Error(`geoTiff:get error: ${text}`)
  }

  const blob = await response.blob()
  return URL.createObjectURL(blob) // usable as <img :src="..." />
}

===== END: src/services/imageFetcher.ts =====

===== START: src/services/geocodingApi.ts =====
export interface GeocodeLatLng {
  lat: number
  lng: number
}

export async function geocodeAddress(address: string, apiKey: string): Promise<GeocodeLatLng> {
  const encoded = encodeURIComponent(address)
  const url = `https://maps.googleapis.com/maps/api/geocode/json?address=${encoded}&key=${apiKey}`

  const response = await fetch(url)
  const data = await response.json()

  if (data.status !== 'OK') {
    console.error('Geocoding error:', data)
    throw new Error(data.error_message || 'Geocoding failed')
  }

  const location = data.results[0].geometry.location
  return { lat: location.lat, lng: location.lng }
}

===== END: src/services/geocodingApi.ts =====

===== START: src/services/dataLayers.ts =====
export interface LatLngCoords {
  latitude: number
  longitude: number
}

export interface DataLayersResponse {
  rgbUrl?: string
  // other urls can be added as needed
}

export async function getDataLayerUrls(
  location: LatLngCoords,
  radiusMeters: number,
  apiKey: string,
): Promise<DataLayersResponse> {
  const args = {
    'location.latitude': location.latitude.toFixed(5),
    'location.longitude': location.longitude.toFixed(5),
    radius_meters: radiusMeters.toString(),
    required_quality: 'LOW',
  }

  const params = new URLSearchParams({ ...args, key: apiKey })

  const response = await fetch(`https://solar.googleapis.com/v1/dataLayers:get?${params}`)
  const content = await response.json()

  if (!response.ok) {
    throw new Error(content.error?.message || 'Failed to fetch data layers')
  }

  return content
}

===== END: src/services/dataLayers.ts =====

===== START: src/services/solarApi.ts =====
export interface LatLng {
  lat: () => number
  lng: () => number
}

export interface BuildingInsightsResponse {
  // Add relevant fields from the response if needed
  name: string
  solarPotential: any
}

export async function findClosestBuilding(
  location: LatLng,
  apiKey: string,
): Promise<BuildingInsightsResponse> {
  const args = {
    'location.latitude': location.lat().toFixed(5),
    'location.longitude': location.lng().toFixed(5),
  }
  const params = new URLSearchParams({ ...args, key: apiKey })

  const response = await fetch(
    `https://solar.googleapis.com/v1/buildingInsights:findClosest?${params}`,
  )
  const content = await response.json()

  if (!response.ok) {
    console.error('API Error:', content)
    throw new Error(content.error?.message || 'API request failed')
  }

  return content
}

===== END: src/services/solarApi.ts =====

